<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Projet C - Interaction Graphique: hw_interface.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_b10ccc864d8635a32b501fe0f6a52f2e.html">include</a>
  </div>
</div>
<div class="contents">
<h1>hw_interface.h File Reference</h1>
<p>Low level interface with the graphic hadware. This interface is based on the SDL library.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="ei__types_8h_source.html">ei_types.h</a>&quot;</code><br/>

<p><a href="hw__interface_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Surface hidden type. A surface represents a 2 dimentional array of pixels where drawing can be done. The displayed screen itself is represented by a surface, it is accessed by <a class="el" href="hw__interface_8h.html#a91dcf1275fecec719a60dd6dfeca40c6">hw_create_window</a>. Other "offscreen" surfaces can be created by <a class="el" href="hw__interface_8h.html#a2e6d0d669973f8e57198909c60410aa9">hw_surface_create</a>.  <a href="#ad9970ae727c438faaf09c58c5defb796"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#acf938165e604a675fe09218a1b3cfb5f">hw_init</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialises access to the low-level operating system services.  <a href="#acf938165e604a675fe09218a1b3cfb5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a6e856924f3b4c8966a870e56a3b1dcb1">hw_quit</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes the access to the low-level operating system services.  <a href="#a6e856924f3b4c8966a870e56a3b1dcb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a91dcf1275fecec719a60dd6dfeca40c6">hw_create_window</a> (<a class="el" href="structei__size__t.html">ei_size_t</a> *size, const <a class="el" href="ei__types_8h.html#a383b9af13bd6a0a893096ead3c4d8e28">ei_bool_t</a> fullScreen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens the main graphical window of the application.  <a href="#a91dcf1275fecec719a60dd6dfeca40c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a2e6d0d669973f8e57198909c60410aa9">hw_surface_create</a> (const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> root, const <a class="el" href="structei__size__t.html">ei_size_t</a> *size, <a class="el" href="ei__types_8h.html#a383b9af13bd6a0a893096ead3c4d8e28">ei_bool_t</a> force_alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates an off-screen drawing surface.  <a href="#a2e6d0d669973f8e57198909c60410aa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a surface allocated by <a class="el" href="hw__interface_8h.html#a2e6d0d669973f8e57198909c60410aa9">hw_surface_create</a>. This must be called on an unlocked surface (see <a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>).  <a href="#a97d0cca63330b33140dd40288ae1022b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gains exclusive access to a surface. Every call to this function must be matched by a call to <a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>. The address of the pixel buffer may change while the surface is unlocked. Thus, <a class="el" href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">hw_surface_get_buffer</a> must called after each call to this function.  <a href="#a1b9b22f29bb9de0b39ea904fd66251be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases the exclusive access to a surface that was locked by <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>.  <a href="#abf4681e5ead295ccf5b3df3ec8adab66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a6fa41442ed6ec84a120734f7c4fca9a3">hw_surface_update_rects</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface, const <a class="el" href="structei__linked__rect__t.html">ei_linked_rect_t</a> *rects)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Requests that a list of rectangular regions of the root surface be updated on screen.  <a href="#a6fa41442ed6ec84a120734f7c4fca9a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#afd8e86abad6a3f16317d74e541d5034d">hw_surface_get_channel_indices</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface, int *ir, int *ig, int *ib, int *ia)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the R, G, B, Alpha channel indices of a surface.  <a href="#afd8e86abad6a3f16317d74e541d5034d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a5bfe7b0284f7d6dad28541d49714faf7">hw_surface_set_origin</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface, const <a class="el" href="structei__point__t.html">ei_point_t</a> origin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the coordinates of the first pixel of the surface's memory. By default, the coordinates of the first pixel are (0, 0). This can be changed by a call to this function. After a call to this function, the function <a class="el" href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">hw_surface_get_buffer</a> returns a different address than before.  <a href="#a5bfe7b0284f7d6dad28541d49714faf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">hw_surface_get_buffer</a> (const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the address of the pixel at coordinated (0, 0) of a surface. This is usually the first pixel of the surface's memory. But after a call to <a class="el" href="hw__interface_8h.html#a5bfe7b0284f7d6dad28541d49714faf7">hw_surface_set_origin</a>, the (0, 0) pixel may point within the surface memory or not. Pixels are ordered by horizontal lines, from top to bottom, and from left to right whitin lines. The pixel buffer of a surface may be moved when the surface is unlocked (<a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>), you must thus call this function after each call to <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>.  <a href="#a8942e332c58a06edd0e639e6743532d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structei__size__t.html">ei_size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a7b92235ad70d5017c843c66affccdcd2">hw_surface_get_size</a> (const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of a surface.  <a href="#a7b92235ad70d5017c843c66affccdcd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structei__rect__t.html">ei_rect_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a6ca488fe7d5e254ffa9d9e332ee76996">hw_surface_get_rect</a> (const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the rectangle of a surface (origin and size).  <a href="#a6ca488fe7d5e254ffa9d9e332ee76996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ei__types_8h.html#a383b9af13bd6a0a893096ead3c4d8e28">ei_bool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a45d51156efa4a28bfccf9f239a132db5">hw_surface_has_alpha</a> (<a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> surface)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells if a surface manages transparency, i.e. if the surface has an alpha channel.  <a href="#a45d51156efa4a28bfccf9f239a132db5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#ad391b77a24c628dc8601111f562aafbc">hw_text_font_create</a> (const char *filename, <a class="el" href="ei__types_8h.html#a2438d9879374e1d4805231e9e407bbae">ei_fontstyle_t</a> style, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a font that can be used to render text. The font must be freed by calling <a class="el" href="hw__interface_8h.html#a2ac46d37db4c40adc10e3afb137f9f02">hw_text_font_free</a>.  <a href="#ad391b77a24c628dc8601111f562aafbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a2ac46d37db4c40adc10e3afb137f9f02">hw_text_font_free</a> (<a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a> font)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a font created by <a class="el" href="hw__interface_8h.html#ad391b77a24c628dc8601111f562aafbc">hw_text_font_create</a>.  <a href="#a2ac46d37db4c40adc10e3afb137f9f02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a0dd8c0a9599e8cf6f2839bbb049d9358">hw_text_compute_size</a> (const char *text, const <a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a> font, int *width, int *height)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the size of a text surface givent the font and the text.  <a href="#a0dd8c0a9599e8cf6f2839bbb049d9358"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a806521541c5a5a80fbf43105270919e4">hw_text_create_surface</a> (const char *text, const <a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a> font, const <a class="el" href="structei__color__t.html">ei_color_t</a> *color)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a surface containing a text. The size of the created surface is just big enough to contain the text. The caller is responsible to release this surface (<a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>) when it is no more needed.  <a href="#a806521541c5a5a80fbf43105270919e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a516f601afd0c045c9fb0af0f92ec82d4">hw_image_load</a> (const char *filename, <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> channels)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a surface and loads into it an image read from a file. The caller is responsible to release this surface (<a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>) when it is no more needed.  <a href="#a516f601afd0c045c9fb0af0f92ec82d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">hw_event_wait_next</a> (struct <a class="el" href="structei__event__t.html">ei_event_t</a> *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lets this processus sleep until a new event is available.  <a href="#a512ddccf5f945ac12df4b5e226b2a974"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a5229a2fd0d772c02890084e3cfd405ee">hw_event_post_app</a> (void *user_param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put an application-generated event on the event queue. This will cause <a class="el" href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">hw_event_wait_next</a> to wake.  <a href="#a5229a2fd0d772c02890084e3cfd405ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a905a7cf30db98048223f17f253e27613">hw_event_schedule_app</a> (int ms_delay, void *user_param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule an application-generated event to be posted after some amount of time. This will cause <a class="el" href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">hw_event_wait_next</a> to wake after this amount of time.  <a href="#a905a7cf30db98048223f17f253e27613"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a55b51924e6fa16839af0576bc8886c02">hw_now</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current time, in seconds, from some arbitraty origin. Can be used to measure elpased time between to calls.  <a href="#a55b51924e6fa16839af0576bc8886c02"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a026cb381ddcadffd54b5da73d782dea2">EI_MOUSEBUTTON_LEFT</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#a18a48d087980072d755e0c585454c48b">EI_MOUSEBUTTON_MIDDLE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__interface_8h.html#add78e49422c7326a48963b9f288da47c">EI_MOUSEBUTTON_RIGHT</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Low level interface with the graphic hadware. This interface is based on the SDL library. </p>
<p>Created by François Bérard on 30.12.11. Copyright 2011 Ensimag. All rights reserved. </p>

<p>Definition in file <a class="el" href="hw__interface_8h_source.html">hw_interface.h</a>.</p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ad9970ae727c438faaf09c58c5defb796"></a><!-- doxytag: member="hw_interface.h::ei_surface_t" ref="ad9970ae727c438faaf09c58c5defb796" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Surface hidden type. A surface represents a 2 dimentional array of pixels where drawing can be done. The displayed screen itself is represented by a surface, it is accessed by <a class="el" href="hw__interface_8h.html#a91dcf1275fecec719a60dd6dfeca40c6">hw_create_window</a>. Other "offscreen" surfaces can be created by <a class="el" href="hw__interface_8h.html#a2e6d0d669973f8e57198909c60410aa9">hw_surface_create</a>. </p>

<p>Definition at line <a class="el" href="hw__interface_8h_source.html#l00030">30</a> of file <a class="el" href="hw__interface_8h_source.html">hw_interface.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a91dcf1275fecec719a60dd6dfeca40c6"></a><!-- doxytag: member="hw_interface.h::hw_create_window" ref="a91dcf1275fecec719a60dd6dfeca40c6" args="(ei_size_t *size, const ei_bool_t fullScreen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> hw_create_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structei__size__t.html">ei_size_t</a> *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ei__types_8h.html#a383b9af13bd6a0a893096ead3c4d8e28">ei_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>fullScreen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens the main graphical window of the application. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Number of horizontal and vertical pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fullScreen</em>&nbsp;</td><td>If true, opens the window in full screen. Otherwise opens a floating window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unlocked drawing surface (see <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>). This surface should not be freed by calling <a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>, it is freed when releasing access to the low-level services by calling <a class="el" href="hw__interface_8h.html#a6e856924f3b4c8966a870e56a3b1dcb1">hw_quit</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5229a2fd0d772c02890084e3cfd405ee"></a><!-- doxytag: member="hw_interface.h::hw_event_post_app" ref="a5229a2fd0d772c02890084e3cfd405ee" args="(void *user_param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hw_event_post_app </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_param</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put an application-generated event on the event queue. This will cause <a class="el" href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">hw_event_wait_next</a> to wake. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_param</em>&nbsp;</td><td>The user parameter that will be retrievable in the event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a905a7cf30db98048223f17f253e27613"></a><!-- doxytag: member="hw_interface.h::hw_event_schedule_app" ref="a905a7cf30db98048223f17f253e27613" args="(int ms_delay, void *user_param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_event_schedule_app </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ms_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>user_param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule an application-generated event to be posted after some amount of time. This will cause <a class="el" href="hw__interface_8h.html#a512ddccf5f945ac12df4b5e226b2a974">hw_event_wait_next</a> to wake after this amount of time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ms_delay</em>&nbsp;</td><td>The amount of time, in milliseconds, to wait before the event is posted in the event queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_param</em>&nbsp;</td><td>The user parameter that will be retrievable in the event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a512ddccf5f945ac12df4b5e226b2a974"></a><!-- doxytag: member="hw_interface.h::hw_event_wait_next" ref="a512ddccf5f945ac12df4b5e226b2a974" args="(struct ei_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_event_wait_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structei__event__t.html">ei_event_t</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lets this processus sleep until a new event is available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>Where to store the new event. The structure must be allocated by the caller. On return, the structure is filled with informations about the new event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a516f601afd0c045c9fb0af0f92ec82d4"></a><!-- doxytag: member="hw_interface.h::hw_image_load" ref="a516f601afd0c045c9fb0af0f92ec82d4" args="(const char *filename, ei_surface_t channels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> hw_image_load </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>channels</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a surface and loads into it an image read from a file. The caller is responsible to release this surface (<a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>) when it is no more needed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The name of the file containing the image. The file can be .png, .tiff, .jpg, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channels</em>&nbsp;</td><td>A surface to define channel ordering: the newly created surface that is returned by this function will have the same channel order as this surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new unlocked surface containing the image. </dd></dl>

</div>
</div>
<a class="anchor" id="acf938165e604a675fe09218a1b3cfb5f"></a><!-- doxytag: member="hw_interface.h::hw_init" ref="acf938165e604a675fe09218a1b3cfb5f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialises access to the low-level operating system services. </p>

</div>
</div>
<a class="anchor" id="a55b51924e6fa16839af0576bc8886c02"></a><!-- doxytag: member="hw_interface.h::hw_now" ref="a55b51924e6fa16839af0576bc8886c02" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hw_now </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current time, in seconds, from some arbitraty origin. Can be used to measure elpased time between to calls. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current time, in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e856924f3b4c8966a870e56a3b1dcb1"></a><!-- doxytag: member="hw_interface.h::hw_quit" ref="a6e856924f3b4c8966a870e56a3b1dcb1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_quit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the access to the low-level operating system services. </p>

</div>
</div>
<a class="anchor" id="a2e6d0d669973f8e57198909c60410aa9"></a><!-- doxytag: member="hw_interface.h::hw_surface_create" ref="a2e6d0d669973f8e57198909c60410aa9" args="(const ei_surface_t root, const ei_size_t *size, ei_bool_t force_alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> hw_surface_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structei__size__t.html">ei_size_t</a> *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a383b9af13bd6a0a893096ead3c4d8e28">ei_bool_t</a>&nbsp;</td>
          <td class="paramname"> <em>force_alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates an off-screen drawing surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>root</em>&nbsp;</td><td>The root window which channel indices will be used. This insures that the offscreen uses the same channel indices (Red, Green, Blue, Alpha) as the root surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Number of horizontal and vertical pixels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>force_alpha</em>&nbsp;</td><td>If true, then the returned surface will use an alpha channel regardless of root having an alpha channel or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unlocked drawing surface (see <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>). The surface should be freed by calling <a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a97d0cca63330b33140dd40288ae1022b"></a><!-- doxytag: member="hw_interface.h::hw_surface_free" ref="a97d0cca63330b33140dd40288ae1022b" args="(ei_surface_t surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a surface allocated by <a class="el" href="hw__interface_8h.html#a2e6d0d669973f8e57198909c60410aa9">hw_surface_create</a>. This must be called on an unlocked surface (see <a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>The surface to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8942e332c58a06edd0e639e6743532d1"></a><!-- doxytag: member="hw_interface.h::hw_surface_get_buffer" ref="a8942e332c58a06edd0e639e6743532d1" args="(const ei_surface_t surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* hw_surface_get_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the address of the pixel at coordinated (0, 0) of a surface. This is usually the first pixel of the surface's memory. But after a call to <a class="el" href="hw__interface_8h.html#a5bfe7b0284f7d6dad28541d49714faf7">hw_surface_set_origin</a>, the (0, 0) pixel may point within the surface memory or not. Pixels are ordered by horizontal lines, from top to bottom, and from left to right whitin lines. The pixel buffer of a surface may be moved when the surface is unlocked (<a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>), you must thus call this function after each call to <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>The surface from which the pixel address is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd8e86abad6a3f16317d74e541d5034d"></a><!-- doxytag: member="hw_interface.h::hw_surface_get_channel_indices" ref="afd8e86abad6a3f16317d74e541d5034d" args="(ei_surface_t surface, int *ir, int *ig, int *ib, int *ia)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_get_channel_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>ig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>ib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>ia</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the R, G, B, Alpha channel indices of a surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>The surface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ir,ig,ib,ia</em>&nbsp;</td><td>Where to store the resulting indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ca488fe7d5e254ffa9d9e332ee76996"></a><!-- doxytag: member="hw_interface.h::hw_surface_get_rect" ref="a6ca488fe7d5e254ffa9d9e332ee76996" args="(const ei_surface_t surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structei__rect__t.html">ei_rect_t</a> hw_surface_get_rect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the rectangle of a surface (origin and size). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>The surface which rectangle is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The rectangle of the surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b92235ad70d5017c843c66affccdcd2"></a><!-- doxytag: member="hw_interface.h::hw_surface_get_size" ref="a7b92235ad70d5017c843c66affccdcd2" args="(const ei_surface_t surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structei__size__t.html">ei_size_t</a> hw_surface_get_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of a surface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>The surface which size is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size of the surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a45d51156efa4a28bfccf9f239a132db5"></a><!-- doxytag: member="hw_interface.h::hw_surface_has_alpha" ref="a45d51156efa4a28bfccf9f239a132db5" args="(ei_surface_t surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ei__types_8h.html#a383b9af13bd6a0a893096ead3c4d8e28">ei_bool_t</a> hw_surface_has_alpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells if a surface manages transparency, i.e. if the surface has an alpha channel. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A boolean: <a class="el" href="ei__types_8h.html#a383b9af13bd6a0a893096ead3c4d8e28a26fdc833ef14f44fa15d81522b6802ec">EI_TRUE</a> means that the surface has an alpha (transparency) channel, <a class="el" href="ei__types_8h.html#a383b9af13bd6a0a893096ead3c4d8e28ad2686863dafff40367aabad2dfdf17db">EI_FALSE</a> means it does not. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b9b22f29bb9de0b39ea904fd66251be"></a><!-- doxytag: member="hw_interface.h::hw_surface_lock" ref="a1b9b22f29bb9de0b39ea904fd66251be" args="(ei_surface_t surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gains exclusive access to a surface. Every call to this function must be matched by a call to <a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>. The address of the pixel buffer may change while the surface is unlocked. Thus, <a class="el" href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">hw_surface_get_buffer</a> must called after each call to this function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>The surface to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bfe7b0284f7d6dad28541d49714faf7"></a><!-- doxytag: member="hw_interface.h::hw_surface_set_origin" ref="a5bfe7b0284f7d6dad28541d49714faf7" args="(ei_surface_t surface, const ei_point_t origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_set_origin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structei__point__t.html">ei_point_t</a>&nbsp;</td>
          <td class="paramname"> <em>origin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the coordinates of the first pixel of the surface's memory. By default, the coordinates of the first pixel are (0, 0). This can be changed by a call to this function. After a call to this function, the function <a class="el" href="hw__interface_8h.html#a8942e332c58a06edd0e639e6743532d1">hw_surface_get_buffer</a> returns a different address than before. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>The surface which origin must be changed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin</em>&nbsp;</td><td>The new coordinates of the first pixel of the surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf4681e5ead295ccf5b3df3ec8adab66"></a><!-- doxytag: member="hw_interface.h::hw_surface_unlock" ref="abf4681e5ead295ccf5b3df3ec8adab66" args="(ei_surface_t surface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>surface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases the exclusive access to a surface that was locked by <a class="el" href="hw__interface_8h.html#a1b9b22f29bb9de0b39ea904fd66251be">hw_surface_lock</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>The surface to unlock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fa41442ed6ec84a120734f7c4fca9a3"></a><!-- doxytag: member="hw_interface.h::hw_surface_update_rects" ref="a6fa41442ed6ec84a120734f7c4fca9a3" args="(ei_surface_t surface, const ei_linked_rect_t *rects)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_surface_update_rects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a>&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structei__linked__rect__t.html">ei_linked_rect_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rects</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Requests that a list of rectangular regions of the root surface be updated on screen. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>The surface returned by <a class="el" href="hw__interface_8h.html#a91dcf1275fecec719a60dd6dfeca40c6">hw_create_window</a>. This function can only be called on *unlocked surfaces* (<a class="el" href="hw__interface_8h.html#abf4681e5ead295ccf5b3df3ec8adab66">hw_surface_unlock</a>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rects</em>&nbsp;</td><td>The list of rectangle to be updated on screen. If NULL, them the entire surface is updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dd8c0a9599e8cf6f2839bbb049d9358"></a><!-- doxytag: member="hw_interface.h::hw_text_compute_size" ref="a0dd8c0a9599e8cf6f2839bbb049d9358" args="(const char *text, const ei_font_t font, int *width, int *height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_text_compute_size </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a>&nbsp;</td>
          <td class="paramname"> <em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the size of a text surface givent the font and the text. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The string of the message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>font</em>&nbsp;</td><td>The font used to render the text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width,height</em>&nbsp;</td><td>Addresses where to store the computed width and height of the text surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a806521541c5a5a80fbf43105270919e4"></a><!-- doxytag: member="hw_interface.h::hw_text_create_surface" ref="a806521541c5a5a80fbf43105270919e4" args="(const char *text, const ei_font_t font, const ei_color_t *color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__interface_8h.html#ad9970ae727c438faaf09c58c5defb796">ei_surface_t</a> hw_text_create_surface </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a>&nbsp;</td>
          <td class="paramname"> <em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structei__color__t.html">ei_color_t</a> *&nbsp;</td>
          <td class="paramname"> <em>color</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a surface containing a text. The size of the created surface is just big enough to contain the text. The caller is responsible to release this surface (<a class="el" href="hw__interface_8h.html#a97d0cca63330b33140dd40288ae1022b">hw_surface_free</a>) when it is no more needed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The string of the message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>font</em>&nbsp;</td><td>The font used to render the text. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>The text color. The alpha parameter is not used. However, the text is rendered with alpha blending to smooth the curves of the letters (anti-aliasing).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly created unlocked surface containing an anti-aliased rendering of the text. The anti-aliasing is implemented with the alpha channel of the surface: pixels on the text's boundaries have some transparency. </dd></dl>

</div>
</div>
<a class="anchor" id="ad391b77a24c628dc8601111f562aafbc"></a><!-- doxytag: member="hw_interface.h::hw_text_font_create" ref="ad391b77a24c628dc8601111f562aafbc" args="(const char *filename, ei_fontstyle_t style, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a> hw_text_font_create </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a2438d9879374e1d4805231e9e407bbae">ei_fontstyle_t</a>&nbsp;</td>
          <td class="paramname"> <em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a font that can be used to render text. The font must be freed by calling <a class="el" href="hw__interface_8h.html#a2ac46d37db4c40adc10e3afb137f9f02">hw_text_font_free</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The path to the file containing the ttf font definition. Can be relative. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>style</em>&nbsp;</td><td>The style of the font (normal, bold, ...). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the characters in pixels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The font. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ac46d37db4c40adc10e3afb137f9f02"></a><!-- doxytag: member="hw_interface.h::hw_text_font_free" ref="a2ac46d37db4c40adc10e3afb137f9f02" args="(ei_font_t font)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_text_font_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ei__types_8h.html#a22c8198e4d641e4bc67bb17f9c6bcda7">ei_font_t</a>&nbsp;</td>
          <td class="paramname"> <em>font</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a font created by <a class="el" href="hw__interface_8h.html#ad391b77a24c628dc8601111f562aafbc">hw_text_font_create</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>font</em>&nbsp;</td><td>The font to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a026cb381ddcadffd54b5da73d782dea2"></a><!-- doxytag: member="hw_interface.h::EI_MOUSEBUTTON_LEFT" ref="a026cb381ddcadffd54b5da73d782dea2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="hw__interface_8h.html#a026cb381ddcadffd54b5da73d782dea2">EI_MOUSEBUTTON_LEFT</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a18a48d087980072d755e0c585454c48b"></a><!-- doxytag: member="hw_interface.h::EI_MOUSEBUTTON_MIDDLE" ref="a18a48d087980072d755e0c585454c48b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="hw__interface_8h.html#a18a48d087980072d755e0c585454c48b">EI_MOUSEBUTTON_MIDDLE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="add78e49422c7326a48963b9f288da47c"></a><!-- doxytag: member="hw_interface.h::EI_MOUSEBUTTON_RIGHT" ref="add78e49422c7326a48963b9f288da47c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="hw__interface_8h.html#add78e49422c7326a48963b9f288da47c">EI_MOUSEBUTTON_RIGHT</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 26 May 2016 for Projet C - Interaction Graphique by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
